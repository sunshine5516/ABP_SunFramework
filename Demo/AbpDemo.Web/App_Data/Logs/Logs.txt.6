WARN  2019-05-28 01:14:19,617 [64   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
DEBUG 2019-05-28 01:14:28,668 [gator] Hangfire.SqlServer.CountersAggregator    - Aggregating records in 'Counter' table...
ERROR 2019-05-28 01:14:35,536 [6eece] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #0716eece' process. Execution will be retried (attempt #13) in 00:02:25 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:14:41,088 [ae8ec] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #ef8ae8ec' process. Execution will be retried (attempt #13) in 00:02:36 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:14:41,089 [e5bee] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #838e5bee' process. Execution will be retried (attempt #13) in 00:02:35 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:14:41,088 [a9f02] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #8e1a9f02' process. Execution will be retried (attempt #13) in 00:02:28 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:14:41,090 [01133] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #82b01133' process. Execution will be retried (attempt #13) in 00:02:26 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:14:41,091 [47230] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #99347230' process. Execution will be retried (attempt #13) in 00:02:30 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:14:41,090 [dafc6] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #7f4dafc6' process. Execution will be retried (attempt #13) in 00:02:46 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:14:41,090 [30319] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #0ca30319' process. Execution will be retried (attempt #13) in 00:02:25 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:14:41,088 [gator] Hangfire.SqlServer.CountersAggregator    - Error occurred during execution of 'Hangfire.SqlServer.CountersAggregator' process. Execution will be retried (attempt #11) in 00:01:40 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection(DbConnection dedicatedConnection, Action`1 action)
   在 Hangfire.SqlServer.CountersAggregator.Execute(CancellationToken cancellationToken)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:14:41,121 [64   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:14:42,402 [tbeat] Hangfire.Server.ServerHeartbeat          - Error occurred during execution of 'ServerHeartbeat' process. Execution will be retried (attempt #13) in 00:02:45 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection(DbConnection dedicatedConnection, Action`1 action)
   在 Hangfire.SqlServer.SqlServerConnection.Heartbeat(String serverId)
   在 Hangfire.Server.ServerHeartbeat.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:14:43,361 [3083b] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #d183083b' process. Execution will be retried (attempt #13) in 00:02:30 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:14:44,286 [72efa] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #db772efa' process. Execution will be retried (attempt #13) in 00:02:38 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:14:44,361 [2651c] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #2842651c' process. Execution will be retried (attempt #13) in 00:02:31 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:14:44,362 [9dd59] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #5a39dd59' process. Execution will be retried (attempt #13) in 00:02:26 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:14:44,402 [47e9d] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #1bc47e9d' process. Execution will be retried (attempt #13) in 00:02:39 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:14:45,258 [duler] Hangfire.Server.DelayedJobScheduler      - Error occurred during execution of 'DelayedJobScheduler' process. Execution will be retried (attempt #13) in 00:02:32 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerConnection.AcquireLock(String resource, TimeSpan timeout)
   在 Hangfire.SqlServer.SqlServerConnection.AcquireDistributedLock(String resource, TimeSpan timeout)
   在 Hangfire.Server.DelayedJobScheduler.UseConnectionDistributedLock[T](JobStorage storage, Func`2 action)
   在 Hangfire.Server.DelayedJobScheduler.EnqueueNextScheduledJob(BackgroundProcessContext context)
   在 Hangfire.Server.DelayedJobScheduler.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:15:01,484 [0f115] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #0aa0f115' process. Execution will be retried (attempt #13) in 00:02:25 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:15:01,528 [91   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:15:08,268 [f4211] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #83cf4211' process. Execution will be retried (attempt #13) in 00:02:25 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:15:10,267 [be998] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #eeebe998' process. Execution will be retried (attempt #13) in 00:02:33 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:15:12,269 [5fc62] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #7ad5fc62' process. Execution will be retried (attempt #13) in 00:02:36 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:15:15,296 [b2f87] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #918b2f87' process. Execution will be retried (attempt #13) in 00:02:29 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:15:15,628 [duler] Hangfire.Server.RecurringJobScheduler    - Error occurred during execution of 'RecurringJobScheduler' process. Execution will be retried (attempt #10) in 00:01:34 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerConnection.AcquireLock(String resource, TimeSpan timeout)
   在 Hangfire.SqlServer.SqlServerConnection.AcquireDistributedLock(String resource, TimeSpan timeout)
   在 Hangfire.Server.RecurringJobScheduler.UseConnectionDistributedLock(JobStorage storage, Action`1 action)
   在 Hangfire.Server.RecurringJobScheduler.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
WARN  2019-05-28 01:15:21,608 [60   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
DEBUG 2019-05-28 01:15:27,163 [nager] Hangfire.SqlServer.ExpirationManager     - Removing outdated records from the 'AggregatedCounter' table...
ERROR 2019-05-28 01:15:36,722 [cf3e6] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #2bccf3e6' process. Execution will be retried (attempt #13) in 00:02:34 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:15:40,275 [chdog] Hangfire.Server.ServerWatchdog           - Error occurred during execution of 'ServerWatchdog' process. Execution will be retried (attempt #12) in 00:02:01 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerConnection.RemoveTimedOutServers(TimeSpan timeOut)
   在 Hangfire.Server.ServerWatchdog.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:15:40,275 [nager] Hangfire.SqlServer.ExpirationManager     - Error occurred during execution of 'Hangfire.SqlServer.ExpirationManager' process. Execution will be retried (attempt #12) in 00:02:13 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection(DbConnection dedicatedConnection, Action`1 action)
   在 Hangfire.SqlServer.ExpirationManager.UseConnectionDistributedLock(SqlServerStorage storage, Action`1 action)
   在 Hangfire.SqlServer.ExpirationManager.Execute(CancellationToken cancellationToken)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:15:40,309 [60   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:16:00,665 [c7304] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #c16c7304' process. Execution will be retried (attempt #13) in 00:02:31 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:16:00,715 [64   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
DEBUG 2019-05-28 01:16:21,121 [gator] Hangfire.SqlServer.CountersAggregator    - Aggregating records in 'Counter' table...
WARN  2019-05-28 01:16:38,660 [49   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:16:52,081 [gator] Hangfire.SqlServer.CountersAggregator    - Error occurred during execution of 'Hangfire.SqlServer.CountersAggregator' process. Execution will be retried (attempt #12) in 00:02:09 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection(DbConnection dedicatedConnection, Action`1 action)
   在 Hangfire.SqlServer.CountersAggregator.Execute(CancellationToken cancellationToken)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:16:52,112 [64   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:17:15,540 [6eece] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #0716eece' process. Execution will be retried (attempt #14) in 00:02:58 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:17:15,638 [duler] Hangfire.Server.RecurringJobScheduler    - Error occurred during execution of 'RecurringJobScheduler' process. Execution will be retried (attempt #11) in 00:01:47 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerConnection.AcquireLock(String resource, TimeSpan timeout)
   在 Hangfire.SqlServer.SqlServerConnection.AcquireDistributedLock(String resource, TimeSpan timeout)
   在 Hangfire.Server.RecurringJobScheduler.UseConnectionDistributedLock(JobStorage storage, Action`1 action)
   在 Hangfire.Server.RecurringJobScheduler.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:17:21,111 [30319] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #0ca30319' process. Execution will be retried (attempt #14) in 00:03:06 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:17:37,288 [72efa] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #db772efa' process. Execution will be retried (attempt #14) in 00:03:00 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:17:38,404 [47e9d] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #1bc47e9d' process. Execution will be retried (attempt #14) in 00:03:01 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:17:39,100 [a9f02] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #8e1a9f02' process. Execution will be retried (attempt #14) in 00:03:00 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:17:40,367 [9dd59] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #5a39dd59' process. Execution will be retried (attempt #14) in 00:03:07 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:17:41,100 [47230] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #99347230' process. Execution will be retried (attempt #14) in 00:03:02 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:17:41,488 [0f115] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #0aa0f115' process. Execution will be retried (attempt #14) in 00:03:08 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:17:41,567 [3083b] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #d183083b' process. Execution will be retried (attempt #14) in 00:03:06 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:17:41,567 [2651c] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #2842651c' process. Execution will be retried (attempt #14) in 00:03:08 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:17:41,568 [01133] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #82b01133' process. Execution will be retried (attempt #14) in 00:03:14 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:17:41,568 [e5bee] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #838e5bee' process. Execution will be retried (attempt #14) in 00:02:54 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:17:41,568 [dafc6] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #7f4dafc6' process. Execution will be retried (attempt #14) in 00:03:13 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:17:41,568 [f4211] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #83cf4211' process. Execution will be retried (attempt #14) in 00:03:01 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:17:41,568 [ae8ec] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #ef8ae8ec' process. Execution will be retried (attempt #14) in 00:02:56 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:17:41,568 [chdog] Hangfire.Server.ServerWatchdog           - Error occurred during execution of 'ServerWatchdog' process. Execution will be retried (attempt #13) in 00:02:47 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerConnection.RemoveTimedOutServers(TimeSpan timeOut)
   在 Hangfire.Server.ServerWatchdog.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:17:41,567 [duler] Hangfire.Server.DelayedJobScheduler      - Error occurred during execution of 'DelayedJobScheduler' process. Execution will be retried (attempt #14) in 00:03:04 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerConnection.AcquireLock(String resource, TimeSpan timeout)
   在 Hangfire.SqlServer.SqlServerConnection.AcquireDistributedLock(String resource, TimeSpan timeout)
   在 Hangfire.Server.DelayedJobScheduler.UseConnectionDistributedLock[T](JobStorage storage, Func`2 action)
   在 Hangfire.Server.DelayedJobScheduler.EnqueueNextScheduledJob(BackgroundProcessContext context)
   在 Hangfire.Server.DelayedJobScheduler.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:17:41,569 [tbeat] Hangfire.Server.ServerHeartbeat          - Error occurred during execution of 'ServerHeartbeat' process. Execution will be retried (attempt #14) in 00:03:03 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection(DbConnection dedicatedConnection, Action`1 action)
   在 Hangfire.SqlServer.SqlServerConnection.Heartbeat(String serverId)
   在 Hangfire.Server.ServerHeartbeat.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:17:41,599 [64   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:17:43,271 [be998] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #eeebe998' process. Execution will be retried (attempt #14) in 00:03:07 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:17:44,299 [b2f87] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #918b2f87' process. Execution will be retried (attempt #14) in 00:03:13 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
DEBUG 2019-05-28 01:17:53,305 [nager] Hangfire.SqlServer.ExpirationManager     - Removing outdated records from the 'AggregatedCounter' table...
ERROR 2019-05-28 01:18:01,961 [5fc62] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #7ad5fc62' process. Execution will be retried (attempt #14) in 00:02:58 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:18:02,007 [17   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:18:08,640 [nager] Hangfire.SqlServer.ExpirationManager     - Error occurred during execution of 'Hangfire.SqlServer.ExpirationManager' process. Execution will be retried (attempt #13) in 00:02:41 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection(DbConnection dedicatedConnection, Action`1 action)
   在 Hangfire.SqlServer.ExpirationManager.UseConnectionDistributedLock(SqlServerStorage storage, Action`1 action)
   在 Hangfire.SqlServer.ExpirationManager.Execute(CancellationToken cancellationToken)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:18:08,671 [91   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:18:10,722 [cf3e6] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #2bccf3e6' process. Execution will be retried (attempt #14) in 00:02:58 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:18:46,588 [c7304] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #c16c7304' process. Execution will be retried (attempt #14) in 00:02:55 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:18:46,619 [64   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
DEBUG 2019-05-28 01:19:01,089 [gator] Hangfire.SqlServer.CountersAggregator    - Aggregating records in 'Counter' table...
WARN  2019-05-28 01:19:07,024 [64   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:19:16,436 [gator] Hangfire.SqlServer.CountersAggregator    - Error occurred during execution of 'Hangfire.SqlServer.CountersAggregator' process. Execution will be retried (attempt #13) in 00:02:27 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection(DbConnection dedicatedConnection, Action`1 action)
   在 Hangfire.SqlServer.CountersAggregator.Execute(CancellationToken cancellationToken)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:19:16,486 [64   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
WARN  2019-05-28 01:19:54,419 [64   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:20:14,773 [6eece] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #0716eece' process. Execution will be retried (attempt #15) in 00:03:21 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:20:14,773 [duler] Hangfire.Server.RecurringJobScheduler    - Error occurred during execution of 'RecurringJobScheduler' process. Execution will be retried (attempt #12) in 00:02:23 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerConnection.AcquireLock(String resource, TimeSpan timeout)
   在 Hangfire.SqlServer.SqlServerConnection.AcquireDistributedLock(String resource, TimeSpan timeout)
   在 Hangfire.Server.RecurringJobScheduler.UseConnectionDistributedLock(JobStorage storage, Action`1 action)
   在 Hangfire.Server.RecurringJobScheduler.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:20:14,805 [9    ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:20:43,576 [chdog] Hangfire.Server.ServerWatchdog           - Error occurred during execution of 'ServerWatchdog' process. Execution will be retried (attempt #14) in 00:03:06 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerConnection.RemoveTimedOutServers(TimeSpan timeOut)
   在 Hangfire.Server.ServerWatchdog.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
DEBUG 2019-05-28 01:20:49,642 [nager] Hangfire.SqlServer.ExpirationManager     - Removing outdated records from the 'AggregatedCounter' table...
ERROR 2019-05-28 01:20:50,574 [e5bee] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #838e5bee' process. Execution will be retried (attempt #15) in 00:03:27 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:20:56,568 [0f115] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #0aa0f115' process. Execution will be retried (attempt #15) in 00:03:21 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:20:56,571 [9dd59] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #5a39dd59' process. Execution will be retried (attempt #15) in 00:03:33 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:20:56,574 [be998] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #eeebe998' process. Execution will be retried (attempt #15) in 00:03:18 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:20:56,576 [nager] Hangfire.SqlServer.ExpirationManager     - Error occurred during execution of 'Hangfire.SqlServer.ExpirationManager' process. Execution will be retried (attempt #14) in 00:02:56 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection(DbConnection dedicatedConnection, Action`1 action)
   在 Hangfire.SqlServer.ExpirationManager.UseConnectionDistributedLock(SqlServerStorage storage, Action`1 action)
   在 Hangfire.SqlServer.ExpirationManager.Execute(CancellationToken cancellationToken)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:20:56,578 [30319] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #0ca30319' process. Execution will be retried (attempt #15) in 00:03:40 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:20:56,580 [duler] Hangfire.Server.DelayedJobScheduler      - Error occurred during execution of 'DelayedJobScheduler' process. Execution will be retried (attempt #15) in 00:03:36 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerConnection.AcquireLock(String resource, TimeSpan timeout)
   在 Hangfire.SqlServer.SqlServerConnection.AcquireDistributedLock(String resource, TimeSpan timeout)
   在 Hangfire.Server.DelayedJobScheduler.UseConnectionDistributedLock[T](JobStorage storage, Func`2 action)
   在 Hangfire.Server.DelayedJobScheduler.EnqueueNextScheduledJob(BackgroundProcessContext context)
   在 Hangfire.Server.DelayedJobScheduler.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:20:56,583 [tbeat] Hangfire.Server.ServerHeartbeat          - Error occurred during execution of 'ServerHeartbeat' process. Execution will be retried (attempt #15) in 00:03:16 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection(DbConnection dedicatedConnection, Action`1 action)
   在 Hangfire.SqlServer.SqlServerConnection.Heartbeat(String serverId)
   在 Hangfire.Server.ServerHeartbeat.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:20:56,575 [2651c] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #2842651c' process. Execution will be retried (attempt #15) in 00:03:42 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:20:56,579 [47230] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #99347230' process. Execution will be retried (attempt #15) in 00:03:41 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:20:56,609 [3083b] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #d183083b' process. Execution will be retried (attempt #15) in 00:03:22 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:20:56,609 [f4211] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #83cf4211' process. Execution will be retried (attempt #15) in 00:03:30 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:20:56,626 [119  ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:21:07,301 [47e9d] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #1bc47e9d' process. Execution will be retried (attempt #15) in 00:03:16 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:21:07,317 [ae8ec] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #ef8ae8ec' process. Execution will be retried (attempt #15) in 00:03:39 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:21:07,318 [dafc6] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #7f4dafc6' process. Execution will be retried (attempt #15) in 00:03:35 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:21:07,317 [b2f87] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #918b2f87' process. Execution will be retried (attempt #15) in 00:03:29 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:21:07,317 [a9f02] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #8e1a9f02' process. Execution will be retried (attempt #15) in 00:03:25 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:21:07,335 [5fc62] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #7ad5fc62' process. Execution will be retried (attempt #15) in 00:03:16 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:21:07,335 [72efa] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #db772efa' process. Execution will be retried (attempt #15) in 00:03:38 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:21:07,335 [01133] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #82b01133' process. Execution will be retried (attempt #15) in 00:03:22 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:21:07,336 [56   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:21:08,724 [cf3e6] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #2bccf3e6' process. Execution will be retried (attempt #15) in 00:03:41 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
DEBUG 2019-05-28 01:21:43,444 [gator] Hangfire.SqlServer.CountersAggregator    - Aggregating records in 'Counter' table...
ERROR 2019-05-28 01:21:58,712 [c7304] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #c16c7304' process. Execution will be retried (attempt #15) in 00:03:21 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:21:58,789 [9    ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:22:13,789 [gator] Hangfire.SqlServer.CountersAggregator    - Error occurred during execution of 'Hangfire.SqlServer.CountersAggregator' process. Execution will be retried (attempt #14) in 00:03:03 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection(DbConnection dedicatedConnection, Action`1 action)
   在 Hangfire.SqlServer.CountersAggregator.Execute(CancellationToken cancellationToken)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:22:13,820 [9    ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
WARN  2019-05-28 01:23:03,326 [118  ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:23:16,743 [duler] Hangfire.Server.RecurringJobScheduler    - Error occurred during execution of 'RecurringJobScheduler' process. Execution will be retried (attempt #13) in 00:02:32 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerConnection.AcquireLock(String resource, TimeSpan timeout)
   在 Hangfire.SqlServer.SqlServerConnection.AcquireDistributedLock(String resource, TimeSpan timeout)
   在 Hangfire.Server.RecurringJobScheduler.UseConnectionDistributedLock(JobStorage storage, Action`1 action)
   在 Hangfire.Server.RecurringJobScheduler.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:23:16,773 [64   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
DEBUG 2019-05-28 01:23:52,578 [nager] Hangfire.SqlServer.ExpirationManager     - Removing outdated records from the 'AggregatedCounter' table...
ERROR 2019-05-28 01:24:06,230 [6eece] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #0716eece' process. Execution will be retried (attempt #16) in 00:04:01 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:24:06,283 [9    ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:24:07,581 [chdog] Hangfire.Server.ServerWatchdog           - Error occurred during execution of 'ServerWatchdog' process. Execution will be retried (attempt #15) in 00:03:40 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerConnection.RemoveTimedOutServers(TimeSpan timeOut)
   在 Hangfire.Server.ServerWatchdog.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:24:07,581 [nager] Hangfire.SqlServer.ExpirationManager     - Error occurred during execution of 'Hangfire.SqlServer.ExpirationManager' process. Execution will be retried (attempt #15) in 00:03:43 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection(DbConnection dedicatedConnection, Action`1 action)
   在 Hangfire.SqlServer.ExpirationManager.UseConnectionDistributedLock(SqlServerStorage storage, Action`1 action)
   在 Hangfire.SqlServer.ExpirationManager.Execute(CancellationToken cancellationToken)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:24:11,320 [9    ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:24:12,584 [tbeat] Hangfire.Server.ServerHeartbeat          - Error occurred during execution of 'ServerHeartbeat' process. Execution will be retried (attempt #16) in 00:03:49 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection(DbConnection dedicatedConnection, Action`1 action)
   在 Hangfire.SqlServer.SqlServerConnection.Heartbeat(String serverId)
   在 Hangfire.Server.ServerHeartbeat.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:24:29,916 [e5bee] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #838e5bee' process. Execution will be retried (attempt #16) in 00:03:55 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:24:29,917 [be998] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #eeebe998' process. Execution will be retried (attempt #16) in 00:03:46 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:24:29,916 [0f115] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #0aa0f115' process. Execution will be retried (attempt #16) in 00:03:46 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:24:29,917 [3083b] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #d183083b' process. Execution will be retried (attempt #16) in 00:03:53 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:24:29,949 [118  ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:24:38,345 [5fc62] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #7ad5fc62' process. Execution will be retried (attempt #16) in 00:04:08 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:24:41,617 [f4211] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #83cf4211' process. Execution will be retried (attempt #16) in 00:04:08 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:24:44,345 [01133] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #82b01133' process. Execution will be retried (attempt #16) in 00:04:04 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:24:44,581 [9dd59] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #5a39dd59' process. Execution will be retried (attempt #16) in 00:04:14 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:24:47,336 [a9f02] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #8e1a9f02' process. Execution will be retried (attempt #16) in 00:03:53 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:24:47,584 [duler] Hangfire.Server.DelayedJobScheduler      - Error occurred during execution of 'DelayedJobScheduler' process. Execution will be retried (attempt #16) in 00:03:55 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerConnection.AcquireLock(String resource, TimeSpan timeout)
   在 Hangfire.SqlServer.SqlServerConnection.AcquireDistributedLock(String resource, TimeSpan timeout)
   在 Hangfire.Server.DelayedJobScheduler.UseConnectionDistributedLock[T](JobStorage storage, Func`2 action)
   在 Hangfire.Server.DelayedJobScheduler.EnqueueNextScheduledJob(BackgroundProcessContext context)
   在 Hangfire.Server.DelayedJobScheduler.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
WARN  2019-05-28 01:24:50,026 [9    ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:24:51,323 [b2f87] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #918b2f87' process. Execution will be retried (attempt #16) in 00:03:46 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:24:51,583 [30319] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #0ca30319' process. Execution will be retried (attempt #16) in 00:04:05 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:25:07,759 [2651c] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #2842651c' process. Execution will be retried (attempt #16) in 00:04:16 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:25:07,761 [dafc6] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #7f4dafc6' process. Execution will be retried (attempt #16) in 00:04:13 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:25:07,759 [ae8ec] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #ef8ae8ec' process. Execution will be retried (attempt #16) in 00:04:07 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:25:07,760 [72efa] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #db772efa' process. Execution will be retried (attempt #16) in 00:03:53 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:25:07,761 [47e9d] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #1bc47e9d' process. Execution will be retried (attempt #16) in 00:03:52 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:25:07,787 [47230] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #99347230' process. Execution will be retried (attempt #16) in 00:03:59 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:25:07,759 [cf3e6] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #2bccf3e6' process. Execution will be retried (attempt #16) in 00:04:04 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:25:07,808 [118  ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
DEBUG 2019-05-28 01:25:16,792 [gator] Hangfire.SqlServer.CountersAggregator    - Aggregating records in 'Counter' table...
ERROR 2019-05-28 01:25:28,154 [gator] Hangfire.SqlServer.CountersAggregator    - Error occurred during execution of 'Hangfire.SqlServer.CountersAggregator' process. Execution will be retried (attempt #15) in 00:03:17 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection(DbConnection dedicatedConnection, Action`1 action)
   在 Hangfire.SqlServer.CountersAggregator.Execute(CancellationToken cancellationToken)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:25:28,154 [c7304] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #c16c7304' process. Execution will be retried (attempt #16) in 00:04:11 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:25:28,207 [97   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
WARN  2019-05-28 01:26:10,006 [100  ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:26:15,768 [duler] Hangfire.Server.RecurringJobScheduler    - Error occurred during execution of 'RecurringJobScheduler' process. Execution will be retried (attempt #14) in 00:02:51 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerConnection.AcquireLock(String resource, TimeSpan timeout)
   在 Hangfire.SqlServer.SqlServerConnection.AcquireDistributedLock(String resource, TimeSpan timeout)
   在 Hangfire.Server.RecurringJobScheduler.UseConnectionDistributedLock(JobStorage storage, Action`1 action)
   在 Hangfire.Server.RecurringJobScheduler.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:26:15,820 [118  ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
WARN  2019-05-28 01:26:36,192 [98   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
WARN  2019-05-28 01:27:14,138 [99   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
WARN  2019-05-28 01:27:34,517 [118  ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
DEBUG 2019-05-28 01:27:50,586 [nager] Hangfire.SqlServer.ExpirationManager     - Removing outdated records from the 'AggregatedCounter' table...
WARN  2019-05-28 01:28:16,310 [119  ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:28:16,597 [6eece] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #0716eece' process. Execution will be retried (attempt #17) in 00:04:33 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:28:16,598 [be998] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #eeebe998' process. Execution will be retried (attempt #17) in 00:04:48 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:28:16,598 [nager] Hangfire.SqlServer.ExpirationManager     - Error occurred during execution of 'Hangfire.SqlServer.ExpirationManager' process. Execution will be retried (attempt #16) in 00:04:03 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection(DbConnection dedicatedConnection, Action`1 action)
   在 Hangfire.SqlServer.ExpirationManager.UseConnectionDistributedLock(SqlServerStorage storage, Action`1 action)
   在 Hangfire.SqlServer.ExpirationManager.Execute(CancellationToken cancellationToken)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:28:16,599 [chdog] Hangfire.Server.ServerWatchdog           - Error occurred during execution of 'ServerWatchdog' process. Execution will be retried (attempt #16) in 00:04:05 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerConnection.RemoveTimedOutServers(TimeSpan timeOut)
   在 Hangfire.Server.ServerWatchdog.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:28:16,600 [tbeat] Hangfire.Server.ServerHeartbeat          - Error occurred during execution of 'ServerHeartbeat' process. Execution will be retried (attempt #17) in 00:04:37 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection(DbConnection dedicatedConnection, Action`1 action)
   在 Hangfire.SqlServer.SqlServerConnection.Heartbeat(String serverId)
   在 Hangfire.Server.ServerHeartbeat.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:28:16,597 [0f115] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #0aa0f115' process. Execution will be retried (attempt #17) in 00:04:24 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:28:21,364 [95   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:28:38,257 [b2f87] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #918b2f87' process. Execution will be retried (attempt #17) in 00:04:34 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:28:38,257 [3083b] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #d183083b' process. Execution will be retried (attempt #17) in 00:04:18 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:28:38,258 [e5bee] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #838e5bee' process. Execution will be retried (attempt #17) in 00:04:33 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:28:38,289 [96   ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:28:40,336 [a9f02] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #8e1a9f02' process. Execution will be retried (attempt #17) in 00:04:25 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:28:42,586 [duler] Hangfire.Server.DelayedJobScheduler      - Error occurred during execution of 'DelayedJobScheduler' process. Execution will be retried (attempt #17) in 00:04:29 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerConnection.AcquireLock(String resource, TimeSpan timeout)
   在 Hangfire.SqlServer.SqlServerConnection.AcquireDistributedLock(String resource, TimeSpan timeout)
   在 Hangfire.Server.DelayedJobScheduler.UseConnectionDistributedLock[T](JobStorage storage, Func`2 action)
   在 Hangfire.Server.DelayedJobScheduler.EnqueueNextScheduledJob(BackgroundProcessContext context)
   在 Hangfire.Server.DelayedJobScheduler.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
DEBUG 2019-05-28 01:28:45,162 [gator] Hangfire.SqlServer.CountersAggregator    - Aggregating records in 'Counter' table...
ERROR 2019-05-28 01:29:13,593 [9dd59] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #5a39dd59' process. Execution will be retried (attempt #17) in 00:04:42 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:29:14,797 [47e9d] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #1bc47e9d' process. Execution will be retried (attempt #17) in 00:04:20 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:29:15,168 [gator] Hangfire.SqlServer.CountersAggregator    - Error occurred during execution of 'Hangfire.SqlServer.CountersAggregator' process. Execution will be retried (attempt #16) in 00:04:11 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection[T](DbConnection dedicatedConnection, Func`2 func)
   在 Hangfire.SqlServer.SqlServerStorage.UseConnection(DbConnection dedicatedConnection, Action`1 action)
   在 Hangfire.SqlServer.CountersAggregator.Execute(CancellationToken cancellationToken)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:29:15,796 [72efa] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #db772efa' process. Execution will be retried (attempt #17) in 00:04:30 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:29:16,358 [5fc62] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #7ad5fc62' process. Execution will be retried (attempt #17) in 00:04:40 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:29:18,359 [01133] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #82b01133' process. Execution will be retried (attempt #17) in 00:04:39 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:29:19,629 [f4211] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #83cf4211' process. Execution will be retried (attempt #17) in 00:04:45 seconds.
System.InvalidOperationException: 超时时间已到。超时时间已到，但是尚未从池中获取连接。出现这种情况可能是因为所有池连接均在使用，并且达到了最大池大小。
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ERROR 2019-05-28 01:29:20,045 [ae8ec] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #ef8ae8ec' process. Execution will be retried (attempt #17) in 00:04:28 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:29:20,045 [cf3e6] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #2bccf3e6' process. Execution will be retried (attempt #17) in 00:04:28 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:29:20,045 [47230] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #99347230' process. Execution will be retried (attempt #17) in 00:04:39 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:29:20,046 [30319] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #0ca30319' process. Execution will be retried (attempt #17) in 00:04:30 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:29:20,077 [118  ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:29:20,765 [dafc6] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #7f4dafc6' process. Execution will be retried (attempt #17) in 00:04:28 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:29:23,764 [2651c] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #2842651c' process. Execution will be retried (attempt #17) in 00:04:40 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
ERROR 2019-05-28 01:29:40,433 [c7304] Hangfire.Server.Worker                   - Error occurred during execution of 'Worker #c16c7304' process. Execution will be retried (attempt #17) in 00:04:36 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerJobQueue.DequeueUsingTransaction(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerJobQueue.Dequeue(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.SqlServer.SqlServerConnection.FetchNextJob(String[] queues, CancellationToken cancellationToken)
   在 Hangfire.Server.Worker.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:29:40,484 [118  ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
WARN  2019-05-28 01:29:45,552 [118  ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
ERROR 2019-05-28 01:30:23,465 [duler] Hangfire.Server.RecurringJobScheduler    - Error occurred during execution of 'RecurringJobScheduler' process. Execution will be retried (attempt #15) in 00:03:18 seconds.
System.Data.SqlClient.SqlException (0x80131904): 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception (0x80004005): 找不到网络路径。
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 Hangfire.SqlServer.SqlServerStorage.CreateAndOpenConnection()
   在 Hangfire.SqlServer.SqlServerConnection.AcquireLock(String resource, TimeSpan timeout)
   在 Hangfire.SqlServer.SqlServerConnection.AcquireDistributedLock(String resource, TimeSpan timeout)
   在 Hangfire.Server.RecurringJobScheduler.UseConnectionDistributedLock(JobStorage storage, Action`1 action)
   在 Hangfire.Server.RecurringJobScheduler.Execute(BackgroundProcessContext context)
   在 Hangfire.Server.ServerProcessExtensions.Execute(IServerProcess process, BackgroundProcessContext context)
   在 Hangfire.Server.AutomaticRetryProcess.Execute(BackgroundProcessContext context)
ClientConnectionId:00000000-0000-0000-0000-000000000000
Error Number:53,State:0,Class:20
WARN  2019-05-28 01:30:23,509 [118  ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
WARN  2019-05-28 01:30:43,931 [119  ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
WARN  2019-05-28 01:31:25,720 [118  ] ion.Users.MakeInactiveUsersPassiveWorker - System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
System.Data.Entity.Core.EntityException: The underlying provider failed on Open. ---> System.Data.SqlClient.SqlException: 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。请验证实例名称是否正确并且 SQL Server 已配置为允许远程连接。 (provider: Named Pipes Provider, error: 40 - 无法打开到 SQL Server 的连接) ---> System.ComponentModel.Win32Exception: 找不到网络路径。
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, SqlCredential credential, Object providerInfo, String newPassword, SecureString newSecurePassword, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, DbConnectionPool pool, String accessToken, Boolean applyTransientFaultHandling, SqlAuthenticationProviderManager sqlAuthProviderManager)
   在 System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal& connection)
   在 System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.ProviderBase.DbConnectionClosed.TryOpenConnection(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   在 System.Data.SqlClient.SqlConnection.TryOpenInner(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   在 System.Data.SqlClient.SqlConnection.Open()
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.<Open>b__36(DbConnection t, DbConnectionInterceptionContext c)
   在 System.Data.Entity.Infrastructure.Interception.InternalDispatcher`1.Dispatch[TTarget,TInterceptionContext](TTarget target, Action`2 operation, TInterceptionContext interceptionContext, Action`3 executing, Action`3 executed)
   在 System.Data.Entity.Infrastructure.Interception.DbConnectionDispatcher.Open(DbConnection connection, DbInterceptionContext interceptionContext)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.<Open>b__2()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.<>c__DisplayClass1.<Execute>b__0()
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute[TResult](Func`1 operation)
   在 System.Data.Entity.SqlServer.DefaultSqlExecutionStrategy.Execute(Action operation)
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Data.Entity.Core.EntityClient.EntityConnection.Open()
   在 System.Data.Entity.DbContextTransaction.EnsureOpenConnection()
   在 System.Data.Entity.DbContextTransaction..ctor(EntityConnection connection, IsolationLevel isolationLevel)
   在 System.Data.Entity.Database.BeginTransaction(IsolationLevel isolationLevel)
   在 Abp.EntityFramework.EntityFramework.Uow.DbContextEfTransactionStrategy.CreateDbContext[TDbContext](String connectionString, IDbContextResolver dbContextResolver) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\DbContextEfTransactionStrategy.cs:行号 41
   在 Abp.EntityFramework.EntityFramework.Uow.EfUnitOfWork.GetOrCreateDbContext[TDbContext](Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\EfUnitOfWork.cs:行号 115
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkExtensions.GetDbContext[TDbContext](IActiveUnitOfWork unitOfWork, Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkExtensions.cs:行号 29
   在 Abp.EntityFramework.EntityFramework.Uow.UnitOfWorkDbContextProvider`1.GetDbContext(Nullable`1 multiTenancySide) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Uow\UnitOfWorkDbContextProvider.cs:行号 28
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Context() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 32
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.get_Table() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 33
   在 Abp.EntityFramework.EntityFramework.Repositories.EfRepositoryBase`3.GetAll() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\Abp.EntityFramework\EntityFramework\Repositories\EfRepositoryBaseOfTEntityAndTPrimaryKey.cs:行号 80
   在 AbpFramework.Domain.Repositories.AbpRepositoryBase`2.GetAllList(Expression`1 predicate) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Repositories\AbpRepositoryBase.cs:行号 58
   在 Castle.Proxies.Invocations.IRepository`2_GetAllList_1.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.IRepository`2Proxy.GetAllList(Expression`1 predicate)
   在 AbpDemo.Core.Authorization.Users.MakeInactiveUsersPassiveWorker.DoWork() 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\Demo\AbpDemo.Core\Authorization\Users\MakeInactiveUsersPassiveWorker.cs:行号 32
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork_callback()
   在 Castle.Proxies.Invocations.MakeInactiveUsersPassiveWorker_DoWork.InvokeMethodOnTarget()
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformSyncUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 65
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.PerformUow(IInvocation invocation, UnitOfWorkOptions options) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 56
   在 AbpFramework.Domain.Uow.UnitOfWorkInterceptor.Intercept(IInvocation invocation) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Domain\Uow\UnitOfWorkInterceptor.cs:行号 45
   在 Castle.DynamicProxy.AbstractInvocation.Proceed()
   在 Castle.Proxies.MakeInactiveUsersPassiveWorkerProxy.DoWork()
   在 AbpFramework.Threading.BackgroundWorkers.PeriodicBackgroundWorkerBase.Timer_Elapsed(Object sender, EventArgs e) 位置 F:\Demo\开源框架\ABP\ABP_SunFramework\src\AbpFramework\Threading\BackgroundWorkers\PeriodicBackgroundWorkerBase.cs:行号 42
